(function (exports, evaluate) {
  'use strict';

  const gi = imports.gi;
  const GLib = gi.GLib;
  const Gio = gi.Gio;
  const GFile = Gio.File;

  const constants = imports.cinnode.constants;
  const DIR_SEPARATOR = constants.DIR_SEPARATOR;
  const TRANSFORM = constants.TRANSFORM;
  const CURRENT_DIR = constants.CURRENT_DIR;

  const modules = Object.create(null);
  const loading = Object.create(null);

  const exp = {
    has: (id) => id in modules,
    get: (id) => modules[id],
    load: load
  };

  function error(module, dir) {
    throw new Error('unable to find module ' + module + ' @ ' + dir);
  }

  function grabModuleFD(path) {
    let fd = GFile.new_for_path(path);
    if (fd.query_exists(null)) {
      switch (fd.query_file_type(Gio.FileQueryInfoFlags.NONE, null)) {
      case Gio.FileType.REGULAR:
        return fd;
      case Gio.FileType.DIRECTORY:
        fd = GFile.new_for_path(path + DIR_SEPARATOR + 'package.json');
        if (fd.query_exists(null)) {
          let content = JSON.parse(String.prototype.trim.call(fd.load_contents(null)[1]));
          if (content.main == null) content.main = 'index.js';
          else if (content.main.slice(-3) !== '.js') content.main += '.js';
          fd = GFile.new_for_path(path + DIR_SEPARATOR + content.main);
          if (fd.query_exists(null)) return fd;
        } else {
          fd = jsMainOrIndex(path);
          if (fd) return fd;
        }
      }
    } else {
      fd = jsMainOrIndex(path);
      if (fd) return fd;
    }
    return null;
  }

  function checkLoading(path) {
    if (loading[path] > 100) throw new Error('Circular dependencies detected: ' + path);
    loading[path] = (loading[path] || 0) + 1;
  }

  function getModuleFile(path, dir) {
    let fd;
    switch (true) {
    case GLib.path_is_absolute(path):
      checkLoading(path);
      fd = grabModuleFD(path);
      if (fd) {
        return fd;
      } else if (path.slice(-3) !== '.js') {
        fd = jsMainOrIndex(path);
        if (fd) return fd;
      }
      return error(path, dir);
    case '.' === path[0]:
      fd = GFile.new_for_path(dir + DIR_SEPARATOR + path);
      return getModuleFile(fd.get_path());
    default:
      checkLoading(path);
      const gPs = [dir].concat(require('module').globalPaths);
      while (gPs.length) {
        let tmp = GFile.new_for_path(gPs.shift());
        do {
          fd = grabModuleFD([
            tmp.get_path(), 'node_modules', path
          ].join(DIR_SEPARATOR));
          if (fd) return fd;
        } while ((tmp = tmp.get_parent()));
      }
      // This is a fix for cases when a node module requires one of its dependencies from a child directory
      if (path.indexOf('.') === -1 && path.indexOf(DIR_SEPARATOR) === -1 && path.indexOf('index') === -1) {
        let newPath = [
          CURRENT_DIR, 'node_modules', path, 'index'
        ].join(DIR_SEPARATOR);
        return getModuleFile(newPath, dir);
      }
      return error(path, dir);
    }
  }

  function jsMainOrIndex(path) {
    let fd = GFile.new_for_path(path + '.js');
    if (fd.query_exists(null)) return fd;
    fd = GFile.new_for_path(path + DIR_SEPARATOR + 'index.js');
    if (fd.query_exists(null)) return fd;
    fd = GFile.new_for_path(path + DIR_SEPARATOR + 'main.js');
    if (fd.query_exists(null)) return fd;
  }

  function load(module, dir) {
    let fd = getModuleFile(module, dir);
    let id = fd.get_path();
    if (exp.has(id) && !window.__DEBUG) {
      return exp.get(id);
    } else if (id.slice(-5) === '.json') {
      let [success, json] = fd.load_contents(null);
      try {
        if (!success) {
          throw new Error();
        }
        return JSON.parse(json);
      } catch (e) {
        error(module, dir);
      }
    } else {
      return evaluate(TRANSFORM, modules, id, id, fd);
    }
  }

  exports.withRuntime = function setup($evaluate) {
    if (!evaluate) evaluate = $evaluate;
    return exp;
  };

}(this));