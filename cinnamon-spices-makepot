#!/usr/bin/python3
import argparse
import json
import os
import subprocess
import sys
from concurrent.futures import ProcessPoolExecutor
from glob import glob
from typing import Any, List, Literal, Optional, Sequence, Tuple, Union
import selectors
from pathlib import Path

CapturedOutput = List[Tuple[Literal["stdout", "stderr"], str]]


def parse_args():
    """
    Get command line arguments and process translation actions
    """
    parser = argparse.ArgumentParser()
    parser.description = 'Arguments for cinnamon-spices-makepot'
    parser.add_argument('-i', '--install', action='store_true',
                        help='Compiles and installs any .po files contained in'
                             ' a spices po folder.'
                             'Use this option to test your translations'
                             ' locally before uploading to Spices.')
    parser.add_argument('-r', '--remove', action='store_true',
                        help='The opposite of install, removes local '
                             'translations.')
    parser.add_argument('-a', '--all', action='store_true',
                        help='Create or update translation templates for all '
                             'Spices')
    parser.add_argument('uuid', type=str, metavar='UUID', nargs='?',
                        help='the UUID of the Spice')
    args = parser.parse_args()
    if args.uuid and args.uuid.endswith('/'):
        args.uuid = args.uuid.replace('/', '')
    if args.all and not args.uuid:
        folders = [file_path for file_path in os.listdir(".") if os.path.isdir(file_path) and not file_path.startswith(".")]
        
        if args.install:
            for folder in folders:
                install_po(folder, True)
        elif args.remove:
            for folder in folders:
                remove_po(folder, True)
        else:
            with ProcessPoolExecutor() as executor:
                for output in executor.map(make_pot, folders):
                    print_output(output)

    elif args.install and args.remove:
        print('Only -i/--install OR -r/--remove may be specified. Not both.')
        sys.exit(1)
    elif args.install and args.uuid:
        install_po(args.uuid)
    elif args.remove and args.uuid:
        remove_po(args.uuid)
    elif args.uuid:
        output = make_pot(args.uuid)
        print_output(output)
    else:
        parser.print_help()
        
def get_command_output(
    cmd: Sequence[Union[str, Path]],
    cwd: Optional[Union[str, Path]] = None, 
    check: bool = True,
    noStderr: bool = False
) -> List[Tuple[Literal["stdout", "stderr"], str]]:
    '''Gather command output in order and preserve stdout/stderr distinction'''
    out = subprocess.Popen(
        cmd,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
        cwd=cwd,
    )
    text: List[Tuple[Literal["stdout", "stderr"], str]] = []
    sel = selectors.DefaultSelector()
    if not noStderr:
        sel.register(out.stdout, selectors.EVENT_READ)
    sel.register(out.stderr, selectors.EVENT_READ)
    
    done = False
    while not done:
        for key, _ in sel.select():
            data = key.fileobj.read1().decode()
            if not data:
                done = True
                break
            if key.fileobj is out.stdout:
                text.append(("stdout", data))
            else:
                text.append(("stderr", data))
    
    exit_code = out.wait()
    if (check and exit_code != 0):
        stdout = map(lambda x: x[1], filter(lambda line: line[0] == "stdout", text))
        stderr = map(lambda x: x[1], filter(lambda line: line[0] == "stderr", text))
        raise subprocess.CalledProcessError(exit_code, cmd, output="".join(stdout), stderr="".join(stderr))
    return text


def install_po(uuid: str, _all: bool = False):
    """
    Install translation files locally from the po directory of the UUID
    """
    uuid_path = f'{uuid}/files/{uuid}'
    try:
        contents = os.listdir(uuid_path)
    except FileNotFoundError:
        print(f'Translations not found for: {uuid}')
        if not _all:
            sys.exit(1)
    home = os.path.expanduser("~")
    locale_inst = f'{home}/.local/share/locale'
    if 'po' in contents:
        po_dir = f'{uuid_path}/po'
        for file in os.listdir(po_dir):
            if file.endswith('.po'):
                lang = file.split(".")[0]
                locale_dir = os.path.join(locale_inst, lang, 'LC_MESSAGES')
                os.makedirs(locale_dir, mode=0o755, exist_ok=True)
                subprocess.run(['msgfmt', '-c', os.path.join(po_dir, file),
                               '-o', os.path.join(locale_dir, f'{uuid}.mo')],
                               check=True)


def remove_po(uuid: str, _all: bool = False):
    """
    Remove local translation files for the UUID
    """
    home = os.path.expanduser("~")
    locale_inst = f'{home}/.local/share/locale'
    uuid_mo_list = glob(f'{locale_inst}/**/{uuid}.mo', recursive=True)
    if not uuid_mo_list:
        print(f'No translation files found for: {uuid}')
        if not _all:
            sys.exit(1)
    for uuid_mo_file in uuid_mo_list:
        os.remove(uuid_mo_file)
        
def print_output(output: CapturedOutput):
    # Flush is needed or we won't print in the right order
    for line in output:
        if line[0] == "stdout":
            print(line[1], end="", file=sys.stderr, flush=True)
        elif line[0] == "stderr":
            print(line[1], end="", file=sys.stdout, flush=True)


def process_po(po_file: str, uuid: str) -> CapturedOutput:
    po_path = Path(po_file)
    po_dir = str(po_path.parent)
    po_file_name = po_path.name
    po_lang = po_path.stem
    out1 = get_command_output(["msguniq", "-o", po_file_name, po_file_name], cwd=po_dir)
    out2 = get_command_output(["intltool-update", "-g", uuid, "-d", po_lang], cwd=po_dir)
    out3 = get_command_output(["msgattrib", "--no-obsolete", "-w", "79", "-o",
                    po_file_name, po_file_name], cwd=po_dir)
    result: CapturedOutput = [("stdout", po_lang + " ")]
    return result + out1 + out2 + out3

def make_pot(uuid: str, should_print: bool = True) -> CapturedOutput:
    """
    Make the translation template file for the UUID
    """
    
    output: CapturedOutput = []
    
    folder = Path(f'{os.getcwd()}/{uuid}')
    output_dir = folder.joinpath(f'files/{uuid}')
    po_dir = output_dir.joinpath("po")
    
    # Prepare the pot file
    pot_file = uuid + '.pot'
    pot_file_path = po_dir.joinpath(pot_file)
    
    if pot_file_path.exists():
        pot_file_path.unlink()
    elif not po_dir.exists():
        po_dir.mkdir()
        
    output += get_command_output(["cinnamon-xlet-makepot", "-o", pot_file_path, folder],
                   check=True, cwd=folder)
    
    pot_file_path.chmod(0o0644)

    # Extract translatable strings from glade
    glade_list = glob(f'{output_dir}/**/*.glade', recursive=True)
    glade_list += glob(f'{output_dir}/**/*.ui', recursive=True)
    for glade_file in glade_list:
        output += get_command_output(["xgettext", "-jL", "Glade", "-o", pot_file_path,
                       glade_file], check=True, cwd=output_dir)
        
    # Extract translatable strings from shell scripts
    shell_list = glob(f'{folder}**/*.sh', recursive=True)
    for shell_file in shell_list:
        get_command_output(["xgettext", "-jL", "Shell", "-o", pot_file_path,
                       shell_file], noStderr=True, check=True, cwd=output_dir)
        
    # Get the metadata file
    metadata_file = f'{uuid}/files/{uuid}/metadata.json'
    try:
        with open(metadata_file, encoding='utf-8') as meta:
            metadata: dict[str, Any] = json.load(meta)
        version = str(metadata['version'])
    except (FileNotFoundError, KeyError):
        output.append(("stdout", f"{uuid}: metadata.json or version not found"))
        version = "1.0"
        
    # Update the pot file with the metadata
    address = 'https://github.com/linuxmint/cinnamon-spices-applets/issues'
    output += get_command_output(["xgettext", "-w", "79", "--package-name", uuid,
                    "--foreign-user", "--msgid-bugs-address", address,
                    "--package-version", version, "-o", pot_file_path, pot_file_path],
                   check=True)
    
    # Process the po files
    glob_path = f'{output_dir}/**/*.po'
    po_list = glob(glob_path, recursive=True)
    for po_file in po_list:
        os.chmod(po_file, 0o0644)        

    with ProcessPoolExecutor() as executor:
        for lines in executor.map(process_po, po_list, [uuid] * len(po_list)):
            output += lines
            
    return output
    


if __name__ == "__main__":
    parse_args()
